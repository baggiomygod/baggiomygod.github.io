---
layout:     post
title:      typescript之泛型
subtitle:   官方文档 笔记
date:       2019-01-16
author:     wengfan
header-img: img/post-bg-ts.png
catalog: true
tags:
    - typescript
    - 学习笔记
---
# 泛型
使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据，这样用户就可以以自己的数据类型来使用组件

## 泛型值hello world

以下函数称之为”泛型“，因为它可以适用于多个类型。不同于使用any，它不会丢失信息，像第一个例子那样保持准确性。

 给identity添加了类型变量T。T帮助我们捕获用户传入的类型，之后我们就可以使用这个类型。
```
    function identity<T>(arg: T): T {
        return arg
    }
```

### 使用泛型
```
    let output = identity<string>('str...') // typeof output will be 'string'

    // or

    let output = identity('str...') // 利用类型推论
```

## 使用泛型变量
```
    function loggifIdentity<T>(arg: T[]): T[] {
        console.log(arg.length)
        return arg
    }
    function loggifIdentity<T>(arg: Array<T>): Array<T> {
        console.log(arg.length)
        return arg
    }
```

## 泛型类型
泛型函数的类型与非泛型函数的类型没什么不同，知识一个类型参数在最前面，像函数声明一样
```
    function indetity<T>(arg: T): T {
        return arg
    }

    let myIdentity: <T>(arg: T) => T = identity
    let myIdentity2: <U>(arg: U) => U = identity
    let myIdentity3: {<T>(arg: T) => T} = identity

    const result = myIdentity('ss')
    console.log(result) // 'ss'
```

## 泛型接口
```
    interface GenericIdentityFn {
        <T>(arg: T): T
    }
    function indetity<T>(arg: T): T {
        return arg
    }
    const myIdentity: GenericIdentityFn = indetity
```

## 泛型类
```
    class GenericNumber<T> {
        value: T;
        add: (a: T, b: T) => T
    }

    const numberInstance = new GenericNumber<number>()
    numberInstance.value = 1
    numberInstance.add = function (num1, num2) {
        return num1 + num2
    }
```

## 泛型约束
(未完)